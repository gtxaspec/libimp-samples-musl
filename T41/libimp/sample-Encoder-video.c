/*
 * sample-Encoder-video.c
 *
 * Copyright (C) 2014 Ingenic Semiconductor Co.,Ltd
 *
 * All API calls used in this file can be found in the header files located in the proj/sdk-lv3/include/api/cn/imp/ directory.
 *
 * Step.1 System init 
 *		@code
 *			memset(&sensor_info, 0, sizeof(sensor_info));
 *			if(SENSOR_NUM == IMPISP_TOTAL_ONE){
 *				memcpy(&sensor_info[0], &Def_Sensor_Info[0], sizeof(IMPSensorInfo));
 *			} else if(SENSOR_NUM == IMPISP_TOTAL_TWO){
 *				memcpy(&sensor_info[0], &Def_Sensor_Info[0], sizeof(IMPSensorInfo) * 2);
 *			}else if(SENSOR_NUM ==IMPISP_TOTAL_THR){
 *				memcpy(&sensor_info[0], &Def_Sensor_Info[0], sizeof(IMPSensorInfo) * 3)
 *			} //Copy the content of Def_Sensor_Info with corresponding size according to the number of sensors into the sensor_info.
 *
 *			ret = IMP_ISP_Open() //Open the ISP module.
 *			ret = IMP_ISP_SetCameraInputMode(&mode) //Setting multi-sensor mode if there are multiple sensors (maximum support for three sensors) (ignore if it's single sensor mode).
 *			ret = IMP_ISP_AddSensor(IMPVI_MAIN, &sensor_info[*]) //Add a sensor to the system. Prior to this step, the sensor driver should have been added to the kernel. The IMPVI_MAIN, IMPVI_SEC, and IMPVI_THR are used to specify the main, secondary, and third sensors, respectively.
 *			ret = IMP_ISP_EnableSensor(IMPVI_MAIN, &sensor_info[*])	//Enable sensor, now the sensor starts outputting images. (IMPVI_MAIN is the main camera, IMPVI_SEC is the secondary camera, IMPVI_THR is the third camera)
 *			ret = IMP_System_Init() //
 *			ret = IMP_ISP_EnableTuning() //Enable ISP tuning, then you can call the ISP debugging interface.
 *		@endcode
 * Step.2 FrameSource init Framesource initialization
 *		@code
 *			ret = IMP_FrameSource_CreateChn(chn[i].index, &chn[i].fs_chn_attr) //Create channel
 *			ret = IMP_FrameSource_SetChnAttr(chn[i].index, &chn[i].fs_chn_attr) //Set the properties of the channel, including: image width, image height, image format, output frame rate of the channel, number of cache buffers, and clipping and scaling properties.
 *		@endcode
 * Step.3 Encoder initialization
 *		@code
 *			ret = IMP_Encoder_CreateGroup(chn[i].index) //Create encoding Group
 *			ret = IMP_Encoder_SetDefaultParam(&channel_attr, chn[i].payloadType, S_RC_METHOD, imp_chn_attr_tmp->picWidth, imp_chn_attr_tmp->picHeight, imp_chn_attr_tmp->outFrmRateNum,
 *											imp_chn_attr_tmp->outFrmRateDen, imp_chn_attr_tmp->outFrmRateNum * 2 / imp_chn_attr_tmp->outFrmRateDen, 2,
 *											(S_RC_METHOD == IMP_ENC_RC_MODE_FIXQP) ? 35 : -1, uTargetBitRate) //Set the default properties for the encoding channel.
 *			ret = IMP_Encoder_CreateChn(chnNum, &channel_attr) //Create encoding channel.
 *			ret = IMP_Encoder_RegisterChn(chn[i].index, chnNum) //Register the encoding channel to the group.
 *		@endcode
 * Step.4 Bind framesource and encoding channel
 *		@code
 *			ret = IMP_System_Bind(&chn[i].framesource_chn, &chn[i].imp_encoder)	//Bind the framesource and encoding channel. After successful binding, the data generated by framesource can be automatically transmitted to the encoding channel.
 *		@endcode
 * Step.5 Stream On Enable Framesource channel to start outputting images.
 *		@code
 *			ret = IMP_FrameSource_EnableChn(chn[i].index) //Enable the channel to start outputting the image.
 *		@endcode
 * Step.6 Get stream 
 *		@code
 *			ret = IMP_Encoder_StartRecvPic(chnNum) //The encoding channel starts to receive images.
 *			ret = IMP_Encoder_PollingStream(chnNum, 1000) //Polling the stream in the encoding channel.
 *			ret = IMP_Encoder_GetStream(chnNum, &stream, 1) //Get encoded stream.
 *			ret = save_stream(stream_fd, &stream) //Save the result to the opened file descriptor.
 *			ret = IMP_Encoder_ReleaseStream(chnNum, &stream) //Release encoded stream. Used in pairs with IMP_Encoder_GetStream.
 *			ret = IMP_Encoder_StopRecvPic(chnNum) //Stop receiving images in encoding channel.
 *		@endcode
 * Step.7 Stream Off: Disable Framesource channel, stop outputting images.
 *		@code
 *			ret = IMP_FrameSource_DisableChn(chn[i].index) //Disable the channel to stop outputting images.
 *		@endcode
 * Step.8 UnBind: Unbind the framesource and encoding channel.
 *		@code
 *			ret = IMP_System_UnBind(&chn[i].framesource_chn, &chn[i].imp_encoder) //Unbind framesource and encoding channel.
 *		@endcode
 * Step.9 Encoder exit Encoder deinitialization
 *		@code
 *			ret = IMP_Encoder_Query(chnNum, &chn_stat) //Querying the status of an encoding channel.
 *			ret = IMP_Encoder_UnRegisterChn(chnNum) //If the encoding channel has already been registered, unregister it from the group.
 *			ret = IMP_Encoder_DestroyChn(chnNum) //Destroy the encoding channel.
 *		@endcode
 * Step.10 FrameSource exit Framesource deinitilization
 *		@code
 *			ret = IMP_FrameSource_DestroyChn(chn[i].index) //Destory channel
 *		@endcode
 * Step.11 System exit System Deinitialization
 *		@code
 *			ret = IMP_ISP_DisableTuning() //Disable ISP tuning
 *			ret = IMP_System_Exit() //System Deinitialization
 *			ret = IMP_ISP_DisableSensor(IMPVI_MAIN, &sensor_info[*]) //Disable sensor, Stop outputting images from sensor (IMPVI_MAIN for main sensor, IMPVI_SEC for secondary sensor, IMPVI_THR for third sensor).
 *			ret = IMP_ISP_DelSensor(IMPVI_MAIN, &sensor_info[*]) //Delete sensor (IMPVI_MAIN is for the main camera, IMPVI_SEC is for the secondary camera, IMPVI_THR is for the third camera).
 *			ret = IMP_ISP_Close() //Disable ISP
 *		@endcode
 * */
#include <stdio.h>
#include <stdlib.h>
#include <imp/imp_log.h>
#include <imp/imp_common.h>
#include <imp/imp_system.h>
#include <imp/imp_framesource.h>
#include <imp/imp_encoder.h>

#include "sample-common.h"

#define TAG "Sample-Encoder-video"

extern struct chn_conf chn[];
static int byGetFd = 0;

int main(int argc, char *argv[])
{
	int i, ret;

    if (argc >= 2) {
        byGetFd = atoi(argv[1]);
    }

	/* Step.1 System init */
	ret = sample_system_init();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "IMP_System_Init() failed\n");
		return -1;
	}

	/* Step.2 FrameSource init */
	ret = sample_framesource_init();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "FrameSource init failed\n");
		return -1;
	}

	/* Step.3 Encoder init */
	for (i = 0; i < FS_CHN_NUM; i++) {
		if (chn[i].enable) {
			ret = IMP_Encoder_CreateGroup(chn[i].index);
			if (ret < 0) {
				IMP_LOG_ERR(TAG, "IMP_Encoder_CreateGroup(%d) error !\n", chn[i].index);
				return -1;
			}
		}
	}

	ret = sample_encoder_init();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Encoder init failed\n");
		return -1;
	}

	/* Step.4 Bind */
	for (i = 0; i < FS_CHN_NUM; i++) {
		if (chn[i].enable) {
			ret = IMP_System_Bind(&chn[i].framesource_chn, &chn[i].imp_encoder);
			if (ret < 0) {
				IMP_LOG_ERR(TAG, "Bind FrameSource channel%d and Encoder failed\n",i);
				return -1;
			}
		}
	}

	/* Step.5 Stream On */
	ret = sample_framesource_streamon();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "ImpStreamOn failed\n");
		return -1;
	}

	/* Step.6 Get stream */
    if (byGetFd) {
        ret = sample_get_video_stream_byfd();
        if (ret < 0) {
            IMP_LOG_ERR(TAG, "Get video stream byfd failed\n");
            return -1;
        }
    } else {
        ret = sample_get_video_stream();
        if (ret < 0) {
            IMP_LOG_ERR(TAG, "Get video stream failed\n");
            return -1;
        }
    }

	/* Exit sequence as follow */
	/* Step.a Stream Off */
	ret = sample_framesource_streamoff();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "FrameSource StreamOff failed\n");
		return -1;
	}

	/* Step.b UnBind */
	for (i = 0; i < FS_CHN_NUM; i++) {
		if (chn[i].enable) {
			ret = IMP_System_UnBind(&chn[i].framesource_chn, &chn[i].imp_encoder);
			if (ret < 0) {
				IMP_LOG_ERR(TAG, "UnBind FrameSource channel%d and Encoder failed\n",i);
				return -1;
			}
		}
	}

	/* Step.c Encoder exit */
	ret = sample_encoder_exit();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Encoder exit failed\n");
		return -1;
	}

	/* Step.d FrameSource exit */
	ret = sample_framesource_exit();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "FrameSource exit failed\n");
		return -1;
	}

	/* Step.e System exit */
	ret = sample_system_exit();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "sample_system_exit() failed\n");
		return -1;
	}

	return 0;
}
