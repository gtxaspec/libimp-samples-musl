/*
 * sample-Encoder-h264-jpeg.c
 *
 * Copyright (C) 2014 Ingenic Semiconductor Co.,Ltd
 *
 * All the API explanations in this file can be found in the header files under the proj/sdk-lv3/include/api/cn/imp/ directory.
 *
 * Step.1 System init 
 *		@code
 *			memset(&sensor_info, 0, sizeof(sensor_info));
 *			if(SENSOR_NUM == IMPISP_TOTAL_ONE){
 *				memcpy(&sensor_info[0], &Def_Sensor_Info[0], sizeof(IMPSensorInfo));
 *			} else if(SENSOR_NUM == IMPISP_TOTAL_TWO){
 *				memcpy(&sensor_info[0], &Def_Sensor_Info[0], sizeof(IMPSensorInfo) * 2);
 *			}else if(SENSOR_NUM ==IMPISP_TOTAL_THR){
 *				memcpy(&sensor_info[0], &Def_Sensor_Info[0], sizeof(IMPSensorInfo) * 3)
 *			} //Copy the contents of Def_Sensor_Info of the corresponding size to sensor_info according to the number of sensors.
 *
 *			ret = IMP_ISP_Open() //Enable ISP module
 *			ret = IMP_ISP_SetCameraInputMode(&mode) //If there are multiple sensors (up to three cameras supported), set the multi-camera mode (please ignore for single-camera setups).
 *			ret = IMP_ISP_AddSensor(IMPVI_MAIN, &sensor_info[*]) //Add sensor, before this operation, the sensor driver has been added to the kernel (IMPVI_MAIN is the main camera, IMPVI_SEC is the secondary camera, IMPVI_THR is the third camera).
 *			ret = IMP_ISP_EnableSensor(IMPVI_MAIN, &sensor_info[*])	//Enable sensor, now the sensor starts outputting images (IMPVI_MAIN is the main camera, IMPVI_SEC is the secondary camera, IMPVI_THR is the third camera).
 *			ret = IMP_System_Init() 
 *			ret = IMP_ISP_EnableTuning() //Enable ISP tuning, then you can call ISP interface
 *		@endcode
 * Step.2 FrameSource init Framesource initialization
 *		@code
 *			ret = IMP_FrameSource_CreateChn(chn[i].index, &chn[i].fs_chn_attr) //Create channel
 *			ret = IMP_FrameSource_SetChnAttr(chn[i].index, &chn[i].fs_chn_attr) //Set the related attributes of the channel, including: image width, image height, image format, output frame rate of the channel, number of buffer buffers, cropping and scaling properties.
 *		@endcode
 * Step.3 Encoder init Encoding initialization.
 *		@code
 *			ret = IMP_Encoder_CreateGroup(chn[i].index) //Create encoding group.
 *			ret = sample_encoder_init() //Video encoding initialization, for specific implementation, please refer to the comments in sample-Encoder-video.c
 *			ret = sample_jpeg_init() //Image encoding initialization, for specific implementation, please refer to the comments in sample-Encoder-jpeg.c
 *		@endcode
 * Step.4 Bind FrameSource and encoding channel.
 *		@code
 *			ret = IMP_System_Bind(&chn[i].framesource_chn, &chn[i].imp_encoder)	//Bind FrameSource and encoding channel. Once bound successfully, the data generated by FrameSource can be automatically transferred to the encoding channel.
 *		@endcode
 * Step.5 Stream On Enable the Framesource channel to start outputting images.
 *		@code
 *			ret = IMP_FrameSource_EnableChn(chn[i].index) //Enable the channel to start outputting images.
 *		@endcode
 * Step.6 Get stream and Snap 
 *		@code
 *			ret = pthread_create(&tid, NULL, h264_stream_thread, NULL) //Use another thread to retrieve and save the stream. Specific implementation can be referred to in the comments of sample-Encoder-video.c.
 *			ret = sample_get_jpeg_snap() //The implementation to capture the stream and save the JPEG encoded image can be found in the sample-Encoder-jpeg.c file.
 *		@endcode
 * Step.7 Stream Off Disable the Framesource channel to stop outputting images.
 *		@code
 *			ret = IMP_FrameSource_DisableChn(chn[i].index) //Disable the channel, stopping the output of images.
 *		@endcode
 * Step.8 UnBind Unbind Framesource and encoding chnnel
 *		@code
 *			ret = IMP_System_UnBind(&chn[i].framesource_chn, &chn[i].imp_encoder) //Unbind Framesource and encoding chnnel
 *		@endcode
 * Step.9 Encoder exit Encoding deinitialization
 *		@code
 *			ret = sample_jpeg_exit() //Image encoding deinitialization, the specific implementation can refer to the comments in sample-Encoder-jpeg.c.
 *			ret = sample_encoder_exit() //Video encoding deinitialization, the specific implementation can refer to the comments in sample-Encoder-video.c.
 *		@endcode
 * Step.10 FrameSource exit Framesource deinitialization
 *		@code
 *			ret = IMP_FrameSource_DestroyChn(chn[i].index) //Destory channel
 *		@endcode
 * Step.11 System exit System deinitialization
 *		@code
 *			ret = IMP_ISP_DisableTuning() //Disable ISP tuning
 *			ret = IMP_System_Exit() //System deinitialization
 *			ret = IMP_ISP_DisableSensor(IMPVI_MAIN, &sensor_info[*]) //Disable the sensor, and the sensor stops outputting images. (IMPVI_MAIN is the main camera, IMPVI_SEC is the secondary camera, IMPVI_THR is the third camera.)
 *			ret = IMP_ISP_DelSensor(IMPVI_MAIN, &sensor_info[*]) //Delete the sensor (IMPVI_MAIN is the main camera, IMPVI_SEC is the secondary camera, IMPVI_THR is the third camera).
 *			ret = IMP_ISP_Close() //Close ISP
 *		@endcode
 * */
#include <pthread.h>
#include <stdio.h>
#include <string.h>

#include <imp/imp_log.h>
#include <imp/imp_common.h>
#include <imp/imp_system.h>
#include <imp/imp_framesource.h>
#include <imp/imp_encoder.h>

#include "sample-common.h"

#define TAG "Sample-Encoder-h265-ivpu-jpeg"

extern struct chn_conf chn[];
IMPEncoderRcMode S_RC_METHOD_MODE = IMP_ENC_RC_MODE_CBR;

static int sample_avpu_ivdc_init()
{
	int i, ret, chnNum = 0;
	int s32picWidth = 0,s32picHeight = 0;
	IMPFSChnAttr *imp_chn_attr_tmp;
	IMPEncoderChnAttr channel_attr;
	for (i = 0; i <  FS_CHN_NUM; i++) {
		if (chn[i].enable) {
			imp_chn_attr_tmp = &chn[i].fs_chn_attr;
			chnNum = chn[i].index;

			memset(&channel_attr, 0, sizeof(IMPEncoderChnAttr));
			s32picWidth = chn[i].fs_chn_attr.picWidth;
			s32picHeight =chn[i].fs_chn_attr.picHeight;
			unsigned int uTargetBitRate = BITRATE_720P_Kbs;
			ret = IMP_Encoder_SetDefaultParam(&channel_attr, chn[i].payloadType, S_RC_METHOD_MODE,
					s32picWidth, s32picHeight,
					imp_chn_attr_tmp->outFrmRateNum, imp_chn_attr_tmp->outFrmRateDen,
					imp_chn_attr_tmp->outFrmRateNum * 2 / imp_chn_attr_tmp->outFrmRateDen, 2,
					(S_RC_METHOD_MODE == IMP_ENC_RC_MODE_FIXQP) ? 35 : -1,
					uTargetBitRate);
			if (ret < 0) {
				IMP_LOG_ERR(TAG, "IMP_Encoder_SetDefaultParam(%d) error !\n", chnNum);
				return -1;
			}
			/*Only the encoding channel registered in the main stream can enable the IVDC mode.*/
			if (0 == chnNum) {
				channel_attr.bEnableIvdc = true;
			}

			ret = IMP_Encoder_CreateChn(chnNum, &channel_attr);
			if (ret < 0) {
				IMP_LOG_ERR(TAG, "IMP_Encoder_CreateChn(%d) error !\n", chnNum);
				return -1;
			}

			ret = IMP_Encoder_RegisterChn(chn[i].index, chnNum);
			if (ret < 0) {
				IMP_LOG_ERR(TAG, "IMP_Encoder_RegisterChn(%d, %d) error: %d\n", chn[i].index, chnNum, ret);
				return -1;
			}
		}
	}

	return 0;
}

static int sample_ivpu_jpeg_ivdc_init()
{
	int i, ret;
	IMPEncoderEncAttr *enc_attr;
	IMPEncoderChnAttr channel_attr;
	IMPFSChnAttr *imp_chn_attr_tmp;

	for (i = 0; i <  FS_CHN_NUM; i++) {
		if (chn[i].enable) {
			imp_chn_attr_tmp = &chn[i].fs_chn_attr;
			memset(&channel_attr, 0, sizeof(IMPEncoderChnAttr));
			enc_attr = &channel_attr.encAttr;
			enc_attr->eProfile = IMP_ENC_PROFILE_JPEG;
			enc_attr->encVputype = IMP_ENC_TPYE_IVPU;
			enc_attr->bufSize = 0;
			enc_attr->uWidth = imp_chn_attr_tmp->picWidth;
			enc_attr->uHeight = imp_chn_attr_tmp->picHeight;
			/*Jpeg Register Main Stream Can Set IVDC Mode*/
			if (0 == chn[i].index) {
				channel_attr.bEnableIvdc = true;
			}

			/* Create Channel */
			ret = IMP_Encoder_CreateChn(4 + chn[i].index, &channel_attr);
			if (ret < 0) {
				IMP_LOG_ERR(TAG, "IMP_Encoder_CreateChn(%d) error: %d\n",
						chn[i].index, ret);
				return -1;
			}

			/* Resigter Channel */
			ret = IMP_Encoder_RegisterChn(i, 4 + chn[i].index);
			if (ret < 0) {
				IMP_LOG_ERR(TAG, "IMP_Encoder_RegisterChn(0, %d) error: %d\n",
						chn[i].index, ret);
				return -1;
			}
		}
	}

	return 0;
}

static int sample_ivpu_jpeg_exit()
{
	int ret = 0, i = 0, chnNum = 0;
	IMPEncoderChnStat chn_stat;

	for (i = 0; i <  FS_CHN_NUM; i++) {
		if (chn[i].enable) {
			chnNum = 4 + chn[i].index;
			memset(&chn_stat, 0, sizeof(IMPEncoderChnStat));
			ret = IMP_Encoder_Query(chnNum, &chn_stat);
			if (ret < 0) {
				IMP_LOG_ERR(TAG, "IMP_Encoder_Query(%d) error: %d\n", chnNum, ret);
				return -1;
			}

			if (chn_stat.registered) {
				ret = IMP_Encoder_UnRegisterChn(chnNum);
				if (ret < 0) {
					IMP_LOG_ERR(TAG, "IMP_Encoder_UnRegisterChn(%d) error: %d\n", chnNum, ret);
					return -1;
				}

				ret = IMP_Encoder_DestroyChn(chnNum);
				if (ret < 0) {
					IMP_LOG_ERR(TAG, "IMP_Encoder_DestroyChn(%d) error: %d\n", chnNum, ret);
					return -1;
				}
			}
		}
	}

	return 0;
}

int main(int argc, char *argv[])
{
	int i, ret;

	chn[0].enable = 1;
	chn[1].enable = 1;
	chn[2].enable = 0;
	/* Step.1 System init */
	ret = sample_system_init();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "IMP_System_Init() failed\n");
		return -1;
	}

	/* Step.2 FrameSource init */
	ret = sample_framesource_init();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "FrameSource init failed\n");
		return -1;
	}

	/* Step.3 Encoder init */
	for (i = 0; i < FS_CHN_NUM; i++) {
		if (chn[i].enable) {
			ret = IMP_Encoder_CreateGroup(chn[i].index);
			if (ret < 0) {
				IMP_LOG_ERR(TAG, "IMP_Encoder_CreateGroup(%d) error !\n", i);
				return -1;
			}
		}
	}
	/*AVPU encoding initialization.*/
	ret = sample_avpu_ivdc_init();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Encoder init failed\n");
		return -1;
	}
	/*IVPU screenshot initialization.*/
	ret = sample_ivpu_jpeg_ivdc_init();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Encoder init failed\n");
		return -1;
	}

	/* Step.4 Bind */
	for (i = 0; i < FS_CHN_NUM; i++) {
		if (chn[i].enable) {
			ret = IMP_System_Bind(&chn[i].framesource_chn, &chn[i].imp_encoder);
			if (ret < 0) {
				IMP_LOG_ERR(TAG, "Bind FrameSource channel%d and Encoder failed\n",i);
				return -1;
			}
		}
	}

	/* Step.5 Stream On */
	ret = sample_framesource_streamon();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "ImpStreamOn failed\n");
		return -1;
	}

	/* Step.6 Get stream and Snap */

	ret = sample_get_h265_jpeg_stream();
	if (ret < 0){
		IMP_LOG_ERR(TAG, "get_stream failed\n");
		return -1;
	}
	/* Step.7 Stream Off */
	ret = sample_framesource_streamoff();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "FrameSource StreamOff failed\n");
		return -1;
	}

	/* Step.8 UnBind */
	for (i = 0; i < FS_CHN_NUM; i++) {
		if (chn[i].enable) {
			ret = IMP_System_UnBind(&chn[i].framesource_chn, &chn[i].imp_encoder);
			if (ret < 0) {
				IMP_LOG_ERR(TAG, "UnBind FrameSource channel%d and Encoder failed\n",i);
				return -1;
			}
		}
	}

	/* Step.9 Encoder exit */
	ret = sample_ivpu_jpeg_exit();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Encoder jpeg exit failed\n");
		return -1;
	}

	ret = sample_encoder_exit();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Encoder exit failed\n");
		return -1;
	}

	/* Step.10 FrameSource exit */
	ret = sample_framesource_exit();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "FrameSource exit failed\n");
		return -1;
	}

	/* Step.11 System exit */
	ret = sample_system_exit();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "sample_system_exit() failed\n");
		return -1;
	}

	return 0;
}
